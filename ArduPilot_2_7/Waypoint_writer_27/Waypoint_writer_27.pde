/*Ardupilot 2.7.0 Waypoint writerUse this release to manually upload waypoints*/#include "defines.h"// you can keep your missions stored here, just uncommment the mission to load: (only 1 at a time.)//#include "mission_sfo_landing.h"#include "mission_example.h"// You DON'T need to edit below this line// ----------------------------------#include <avr/io.h>#include <avr/eeprom.h>// 3D Location vectors// -------------------struct Location {        long lat;        long lng;        long alt;};const long t7 = 10000000;	// used to scale GPS values for EEPROM storageconst long t6 = 1000000;	// used to scale GPS values for EEPROM storagebyte wp_total;byte options;void setup(){	Serial.begin(38400);	delay(500);	Serial.println("Waypoint writer");	writeDefaults(); 	// saves default values to system	writePoints();  	// saves Waypoint Array	eeprom_busy_wait();	byte options = eeprom_read_byte((uint8_t *)	EE_CONFIG);	eeprom_busy_wait();	int hold = eeprom_read_word((uint16_t *)	EE_ALT_HOLD_HOME);	eeprom_busy_wait();	byte radius = eeprom_read_byte((uint8_t *)	EE_WP_RADIUS);	delay(1000);	Serial.print("Config tool options:");	Serial.println(options, BIN);	Serial.print("Alt to hold:");	Serial.println(hold ,DEC);	Serial.print("WP Radius:");	Serial.println(radius ,DEC);	Serial.print("total # of points:");	Serial.println(wp_total ,DEC);	readPoints();}void loop(){}void writePoints(){    int mem_position;	struct Location loc;	// number of waypoints	wp_total = sizeof(wayPoints)/12;		// save the alitude above home option	if(OPTION_HOLD_CURRENT_ALT == 1){		eeprom_busy_wait();		eeprom_write_byte((uint8_t *)	EE_CONFIG, 8);	}else{		eeprom_busy_wait();		eeprom_write_byte((uint8_t *)	EE_CONFIG, 0);	}		eeprom_busy_wait();	eeprom_write_word((uint16_t *)	EE_ALT_HOLD_HOME, ALT_TO_HOLD);		// save # of points	eeprom_busy_wait();	eeprom_write_byte((uint8_t *)	EE_WP_TOTAL, wp_total);	// save index	eeprom_busy_wait();	eeprom_write_byte((uint8_t *)	EE_WP_INDEX, 0);	// save WP_Radius	eeprom_busy_wait();	eeprom_write_byte((uint8_t *)	EE_WP_RADIUS, WP_RADIUS);	//set home as 0	eeprom_busy_wait();	eeprom_write_word((uint16_t *)	EE_HOME_ALT, 0);	eeprom_busy_wait();	// alt	eeprom_write_dword((uint32_t *)	EE_HOME_LAT, 0);	eeprom_busy_wait();	// lat	eeprom_write_dword((uint32_t *)	EE_HOME_LNG, 0);						// long		    for (byte i = 0; i < wp_total; i++){    	    	loc.lat = (long)(wayPoints[i][0] * t6);    	loc.lng = (long)(wayPoints[i][1] * t6);    	loc.alt = 0;    	loc.alt = (int)wayPoints[i][2];    	Serial.print((i+1),DEC);    	Serial.print(": ");    	Serial.print(loc.lat,DEC);    	Serial.print(", ");    	Serial.print(loc.lng,DEC);    	Serial.print(", ");    	Serial.println(loc.alt,DEC);    	mem_position = (int)(WP_START_BYTE) + (i * WP_SIZE);    	eeprom_busy_wait();				eeprom_write_dword((uint32_t *)	mem_position, loc.lat);		mem_position += 4;		eeprom_busy_wait();		eeprom_write_dword((uint32_t *)	mem_position, loc.lng);		mem_position += 4;		eeprom_busy_wait();		eeprom_write_word((uint16_t *)	mem_position, (int)loc.alt);	}	}void readPoints(){	eeprom_busy_wait();	wp_total = eeprom_read_byte((uint8_t *)	EE_WP_TOTAL);	    for (byte i = 1; i <= wp_total; i++){   		struct Location temp = get_wp_with_index(i);		Serial.print("waypoint # ");		Serial.print(i,DEC);		Serial.print("\tlat: ");		Serial.print(temp.lat,DEC);		Serial.print("\tlong: ");		Serial.print(temp.lng,DEC);		Serial.print("\talt: ");		Serial.println(temp.alt,DEC);	}}void writeDefaults(void){	eeprom_busy_wait();	eeprom_write_byte((uint8_t *)	EE_CONFIG,		0);			eeprom_busy_wait(); //config tool options	eeprom_write_byte((uint8_t *)	EE_WP_RADIUS, 	20);		eeprom_busy_wait();	// default WP radius	eeprom_write_word((uint16_t *)	EE_AP_OFFSET,  	288);		eeprom_busy_wait();	// air_speed_offset	eeprom_write_word((uint16_t *)	EE_IR_MAX, 		200);		eeprom_busy_wait();	// ir_max }struct Location get_wp_with_index(int i){	struct Location temp;	long mem_position;	// Find out proper location in memory by using the start_byte position + the index	// --------------------------------------------------------------------------------	if (i == 0) {		// read home position 		temp.alt = 0;		eeprom_busy_wait();		temp.lat = (long)eeprom_read_dword((uint32_t*)EE_HOME_LAT);eeprom_busy_wait();		temp.lng = (long)eeprom_read_dword((uint32_t*)EE_HOME_LNG);eeprom_busy_wait();		temp.alt = (long)eeprom_read_word((uint16_t*)EE_HOME_ALT);		temp.lat *= 10;		temp.lng *= 10;		temp.alt *= 100;		return temp;			}else{		// read WP position 		mem_position = (long)(WP_START_BYTE + (i-1) * WP_SIZE);		eeprom_busy_wait();		temp.lat = (long)eeprom_read_dword((uint32_t*)mem_position);		mem_position += 4;		eeprom_busy_wait();		temp.lng = (long)eeprom_read_dword((uint32_t*)mem_position);		mem_position += 4;		temp.alt = 0;		eeprom_busy_wait();		temp.alt = (long)eeprom_read_word((uint16_t*)mem_position);				temp.lat *= 10;		temp.lng *= 10;		temp.alt *= 100;		return temp;	}}